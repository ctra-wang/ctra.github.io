<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>ctra王大大 | CTRA王大大`blog</title>
<meta name="description" content="CTRA王大大">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://holyson.github.io/ctra.github.io//favicon.ico?v=1584861931947">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://holyson.github.io/ctra.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://holyson.github.io/ctra.github.io/">
        <img src="https://holyson.github.io/ctra.github.io//images/avatar.png?v=1584861931947" class="site-logo">
        <h1 class="site-title">CTRA王大大`blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://holyson.github.io/ctra.github.io/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://holyson.github.io/ctra.github.io//tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://holyson.github.io/ctra.github.io//post/about/" class="site-nav">
            关于
          </a>
        
      
        
          <a href="https://holyson.github.io/ctra.github.io//archives" class="site-nav">
            文章
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      CTRA王大大
    </div>
    <div class="site-footer">
      Powered by <a href="https://holyson.github.io/ctra.github.io/" target="_blank">ctra王大大</a> | <a class="rss" href="https://holyson.github.io/ctra.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">ctra王大大</h2>
            <div class="post-date">2020-03-21</div>
            
            <div class="post-content">
              <h1 id="前言">前言</h1>
<h1 id="1c基础知识">1.C++基础知识</h1>
<h3 id="11关于c">1.1	关于C++</h3>
<p>1.1.1  C++的源文件拓展名是：cpp（c plus plus的简称）<br>
1.1.2  C++程序的入口是main函数（函数即方法，一个意思）<br>
1.1.3  C++完全兼容C语言的语法，很久以前，C++叫做C with classes<br>
1.1.4  C++发展史<br>
<img src="https://img-blog.csdnimg.cn/20200321091553975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="12-第一个c程序-hello-world">1.2  第一个C++程序 hello world</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="13-cin-cout-endl-的使用">1.3  cin、cout、endl 的使用</h3>
<p>1.3.1	C++中常使用cin、cout进行控制台的输入、输出<br>
1.3.2	使用cin cout 需要依赖#include <iostream>和using namespace std;<br>
1.3.3	cin用右移运算符&gt;&gt;，cout用的是左移运算符&lt;&lt;<br>
1.3.4	endl 是换行的意思</p>
<h1 id="2函数重载-overload">2.函数重载 - Overload</h1>
<h3 id="21规则">2.1	规则</h3>
<p>2.1.1	函数名相同<br>
2.1.2	参数个数不同、参数类型不同、参数顺序不同</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int sum(int v1, int v2) {
	return v1 + v2;
}
int sum(int v1, int v2, int v3) {
	return v1 + v2 + v3;
}
int main() {
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	cout &lt;&lt; sum(10, 20,30) &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="22注意">2.2	注意</h3>
<p>2.2.1	返回值类型与函数重载无关<br>
2.2.2	调用函数时，实参的隐式类型转换可能会产生二义性<br>
<font color="red">注意： C语言不支持函数重载、C++支持函数重载</font></p>
<h3 id="23本质">2.3	本质</h3>
<p>采用了name mangling或者叫做name decoration技术<br>
重载时会生成多个不同的函数名，不同编译器（MSVC、g++）有不同的生成规则<br>
通过IDA打开[vs 下 release 禁止优化] 可以看到</p>
<p>release下会进行优化（可以禁止）<br>
debug 下可以查询所有反汇编<br>
<img src="https://img-blog.csdnimg.cn/20200321095603761.png" alt="在这里插入图片描述"></p>
<h1 id="3默认参数">3.默认参数</h1>
<h3 id="31c允许函数设置默认参数在调用时可以根据情况省略实参">3.1	C++允许函数设置默认参数，在调用时可以根据情况省略实参</h3>
<p>规则如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int sum(int v1 , int v2 = 6) {
	return v1 + v2;
}

int main() {
	cout &lt;&lt; sum(10) &lt;&lt; endl;
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	return 0;

}
</code></pre>
<h5 id="311默认参数只能按照右到左的顺序">3.1.1		默认参数只能按照右到左的顺序</h5>
<p>如下面代码<font color="red">写法错误</font>，v2的赋值不能缺失</p>
<pre><code class="language-cpp">int sum(int v1 = 10, int v2 ) { //错！！！！
	return v1 + v2;  
}
</code></pre>
<h5 id="312font-colorred如果函数同时有声明-实现默认参数只能放在函数声明中font">3.1.2		<font color="red">如果函数同时有声明、实现，默认参数只能放在函数声明中</font></h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
//声明
int sum(int v1, int v2 = 6);

int main() {
	cout &lt;&lt; sum(10) &lt;&lt; endl;
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	return 0;

}
//实现
int sum(int v1, int v2) {
	return v1 + v2;
}
</code></pre>
<h5 id="313默认参数的值可以是常量-全局符号全局变量-函数名">3.1.3		默认参数的值可以是常量、全局符号（全局变量、函数名）</h5>
<p>1）	默认参数值是全局变量</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int age = 20;
int sum(int v1, int v2 = age) {
	return v1 + v2;
}
int main() {
	cout &lt;&lt; sum(10) &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>2）	指向函数的指针调用函数<br>
(*p)(int) ：（*p）是指向函数的指针 （int）为参数类型</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int age = 20;
void  test(int a) {
	cout &lt;&lt; &quot;test(int)&quot; &lt;&lt; a &lt;&lt; endl;
}

int main() {
	void (*p)(int) = test;
	(*p)(age);
	p(age);
	return 0;

}
</code></pre>
<p>可见	(*p)(age); 和 p(age); 是一样的</p>
<pre><code class="language-c">	(*p)(age);
00111D0F 8B F4                mov         esi,esp  
00111D11 A1 00 C0 11 00       mov         eax,dword ptr ds:[0011C000h]  
00111D16 50                   push        eax  
00111D17 FF 55 F8             call        dword ptr [ebp-8]  
00111D1A 83 C4 04             add         esp,4  
00111D1D 3B F4                cmp         esi,esp  
00111D1F E8 66 F5 FF FF       call        0011128A  
	p(age);
00111D24 8B F4                mov         esi,esp  
00111D26 A1 00 C0 11 00       mov         eax,dword ptr ds:[0011C000h]  
00111D2B 50                   push        eax  
00111D2C FF 55 F8             call        dword ptr [ebp-8]  
00111D2F 83 C4 04             add         esp,4  
00111D32 3B F4                cmp         esi,esp  
00111D34 E8 51 F5 FF FF       call        0011128A
</code></pre>
<p>3）	默认参数值是函数名</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int age = 20;

void  test(int a) {
	cout &lt;&lt; &quot;test(int):&quot; &lt;&lt; a &lt;&lt; endl;
}

void func(int v1, void(*p)(int) = test) {
	p(v1);
}

int main() {
	func(30);
	return 0;

}
</code></pre>
<h3 id="32二义性">3.2	二义性</h3>
<h5 id="321函数重载-默认参数可能会产生冲突-二义性建议优先选择使用默认参数">3.2.1		函数重载、默认参数可能会产生冲突、二义性（建议优先选择使用默认参数）</h5>
<p><img src="https://img-blog.csdnimg.cn/20200321103027912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-extern-c">4. extern  &quot;C&quot;</h1>
<h3 id="41extern-c-作用">4.1	extern &quot;C&quot; 作用</h3>
<p>被 extern &quot;C&quot; 修饰的代码会按照C语言的方式去编译</p>
<h3 id="42c语言不支持重载">4.2	C语言不支持重载</h3>
<img src="https://img-blog.csdnimg.cn/20200321123306953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" width="40%" alt=""/>
<h3 id="43俩种写法">4.3	俩种写法</h3>
<pre><code class="language-cpp">extern &quot;C&quot; void func() {
}
extern &quot;C&quot; void func(int v) {
}
</code></pre>
<pre><code class="language-cpp">extern &quot;C&quot; {
	void func() {
	}
	void func(int v) {
	}
}
</code></pre>
<h3 id="44有声明和实现的函数-与-extern-c">4.4	有声明和实现的函数 与 extern &quot;C&quot;</h3>
<h5 id="441如果函数同时有声明和实现font-colorred-要让函数声明被-extern-c修饰font函数实现可以不修饰">4.4.1		如果函数同时有声明和实现，<font color="red" >要让函数声明被 extern &quot;C&quot;修饰</font>，函数实现可以不修饰</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// 函数声明
void func();
extern &quot;C&quot; void func(int v);

int main() {
	return 0;
}
// 函数实现
void func() {
}
void func(int v) {
}
</code></pre>
<h3 id="45c-c-混合开发">4.5	C、C++ 混合开发</h3>
<h5 id="451由于c-c编译规则不同在c-c混合开发时可能会经常出现以下操作">4.5.1		由于C、C++编译规则不同，在C、C++混合开发时，可能会经常出现以下操作</h5>
<p>C++在调用C语言API 时，需要使用extern “C” 修饰C语言的函数声明</p>
<p><img src="https://img-blog.csdnimg.cn/20200321125133282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
在C++ 中引用C文件，声明时需要加上extern &quot;C&quot;，否则报错<br>
<img src="https://img-blog.csdnimg.cn/2020032112583246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="452-define-__cplusplus">4.5.2 	#define __cplusplus</h5>
<p>只要在C++文件中，默认定义宏 #define __cplusplus （一般不可见）<br>
可以用这个宏来判断是否为C++文件</p>
<p>1）math.c</p>
<pre><code class="language-cpp">#include &quot;math.h&quot;
//include 是为了在.c文件中
//调用自己不报错
int sum(int v1, int v2) {
	return v1 + v2;
}
</code></pre>
<p>2）main.cpp</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

#include &quot;math.h&quot;
extern &quot;C&quot; {
	void other();
}

int main() {
	other();
	cout &lt;&lt; sum(10, 20) &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>3）math.h</p>
<pre><code class="language-cpp">
#ifdef __cplusplus
extern  &quot;C&quot; {
#endif // __cplusplus

int sum(int v1, int v2);

#ifdef __cplusplus
}
#endif // __cplusplus
</code></pre>
<p>4）math.h</p>
<pre><code class="language-cpp">#include &quot;math.h&quot;
#include &lt;stdio.h&gt;
void other() {
	int a = sum(10, 99);
	printf(&quot;a= %d\n&quot;,a);
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200321131819896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="443-防止头文件重复包含">4.4.3 	防止头文件重复包含</h5>
<p>我们经常使用 #ifndef、#define、#endif 来防止头文件的内容被重复包含</p>
<pre><code class="language-cpp">#ifndef __MATH_H
#define __MATH_H

#ifdef __cplusplus
extern  &quot;C&quot; {
#endif // __cplusplus

int sum(int v1, int v2);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __MATH_H
</code></pre>
<img src="https://img-blog.csdnimg.cn/20200321132628607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" width="60%" alt=""/>
<h5 id="444-pragma-once">4.4.4 	#pragma once</h5>
<p>#pragma once 可以防止整个文件的内容被重复包含<br>
<font color="red" >#ifndef、#define、#endif  与  #pragma once 区别 ：</font><br>
1）#ifndef、#define、#endif 受C\C++标准的支持，不收编译器的任何限制<br>
2）有些编译器不支持#pragma once （较老编译器不支持，如GCC 3.4版本之前），兼容性不够好<br>
3）#ifndef、#define、#endif 可以针对一个文件中的部分代码，而#pragma once只能针对整个文件</p>
<h1 id="5内联函数-inline-function">5.内联函数- inline function</h1>
<h3 id="51-inline-修饰符">5.1 inline 修饰符</h3>
<p>5.1.1	使用 inline 修饰函数的声明或者实现 ，可以使其变成内联函数<br>
5.1.2	建议声明和实现都增加 inline 修饰</p>
<h3 id="52-特点">5.2 特点</h3>
<p>5.2.1	编译器会将函数调用直接展开为函数体代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

inline int sum;
inline int sum(int v1, int v2) {
	return v1 + v2;
}

int main() {
	int c = sum(10, 20);
    //	等价于
	//int c =  v1 + v2;
    int c =  10 + 20;
	return 0;
}
</code></pre>
<p>5.2.2	如果不使用	inline 函数,被调用 func的函数体只会保留一份 （即：cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void func() {
	cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;
}

int main() {
	func();
    func();
	func();
    func();
    
	return 0;
}
</code></pre>
<p>5.2.3	可以减少函数调用的开销（不存在函数调用，程序直接运行函数体内容）</p>
<p>5.2.4	会增大代码体积</p>
<p><font color=red size=2>注意</font></p>
<p><font color=red size=2>1）尽量不要内联超过10行代码的函数</font></p>
<p><font color=red size=2>2）有些函数即使声明为inline 也不一定会被编译器内联，比如：递归函数</font></p>
<h3 id="53-什么时候使用内联函数">5.3 什么时候使用内联函数？</h3>
<p>5.3.1	函数代码体积不大</p>
<p>5.3.2	频繁调用的函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//====================  声明	====================
void func();
inline int sum(int v1, int v2);

//====================  实现	====================
//开辟 栈空间
void func() {
	cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl;
}
//回收 栈空间

inline int sum(int v1, int v2) {
	return v1 + v2;
}

int main() {
	func();
	int c = sum(10, 20);
	cout &lt;&lt; c &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<h3 id="54-vs窥探内联的本质">5.4 VS窥探内联的本质</h3>
<h5 id="541-如果-inline-内联生效后在反汇编中应该看不到定义的函数如543内联的效果">5.4.1 	如果 inline 内联生效后，在反汇编中应该看不到定义的函数（如：5.4.3	内联的效果）</h5>
<h5 id="542如何在-vs2019-中进行设置">5.4.2		如何在 VS2019 中进行设置</h5>
<p><img src="https://img-blog.csdnimg.cn/20200320181328380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/2020032018134571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="543内联的效果">5.4.3		内联的效果</h5>
<pre><code class="language-assembly">--- E:\C++-程序\05-内联函数\05-内联函数\main.cpp -----------------------------------------
	func();
00291000  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (029305Ch)]  
00291006  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (0291320h)  
0029100B  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (0291100h)  
00291010  mov         ecx,eax  
00291012  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0293038h)]  
	int c = sum(10, 20);
	cout &lt;&lt; c &lt;&lt; endl;
00291018  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (029305Ch)]  
0029101E  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (0291320h)  
00291023  push        1Eh  
00291025  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0293034h)]  
0029102B  mov         ecx,eax  
0029102D  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0293038h)]  
	getchar();
00291033  call        dword ptr [__imp__getchar (02930F0h)]  
	return 0;
00291039  xor         eax,eax  
}
</code></pre>
<h5 id="544非内联的效果">5.4.4		非内联的效果</h5>
<pre><code class="language-assembly">	func();
01052078  call        func (01051424h)  
	int c = sum(10, 20);
0105207D  push        14h  
0105207F  push        0Ah  
01052081  call        sum (01051429h)  
01052086  add         esp,8  
01052089  mov         dword ptr [c],eax  
	cout &lt;&lt; c &lt;&lt; endl;
0105208C  mov         esi,esp  
0105208E  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (010512B7h)  
01052093  mov         edi,esp  
01052095  mov         eax,dword ptr [c]  
01052098  push        eax  
01052099  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (0105D0D8h)]  
0105209F  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0105D0A0h)]  
010520A5  cmp         edi,esp  
	cout &lt;&lt; c &lt;&lt; endl;
010520A7  call        __RTC_CheckEsp (0105128Fh)  
010520AC  mov         ecx,eax  
010520AE  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (0105D0A4h)]  
010520B4  cmp         esi,esp  
010520B6  call        __RTC_CheckEsp (0105128Fh)  
</code></pre>
<h3 id="55内联函数与宏">5.5.内联函数与宏</h3>
<h5 id="551相同点内联函数和宏都能减少函数调用的开销">5.5.1		相同点：内联函数和宏都能减少函数调用的开销</h5>
<h5 id="552对比宏内联函数多了语法检测和函数特性">5.5.2		对比宏，内联函数多了语法检测和函数特性</h5>
<p><font color=red size=2>而且宏会将普通的运算改变</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

inline int sum(int v) {
	 return v  + v ;
}
//定义宏
#define add(v)(v + v)

int main() {
	int a = 10;
	int b = 10;
	int c = sum(++a);
	int d = add(++b);
	cout &lt;&lt; c &lt;&lt; endl;
	cout &lt;&lt; d &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>输出结果 ：22		24</p>
<p><font color=red size=2>可以看出宏将++a 操作复杂化了</font></p>
<h3 id="56-表达式">5.6 表达式</h3>
<h5 id="561表达式性质仅为-c特性c语言没有此性质">5.6.1		表达式性质仅为 C++特性，C语言没有此性质</h5>
<p><img src="https://img-blog.csdnimg.cn/20200320181406166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsZWkxOTg5MTIxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="562表达式实例1">5.6.2		表达式实例1</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//表达式
int main() {
	int a = 1;
	int b = 2;
    
	(a = b) = 4;
    
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>输出结果：a=4<br>
b=12</p>
<h5 id="563表达式实例2">5.6.3		表达式实例2</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//表达式
int main() {
	int a = 1;
	int b = 2;
    
	(a &gt; b ? a : b) = 10;
    
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>输出结果：a=1<br>
b=10</p>
<h1 id="6常量-const">6.常量 -  const</h1>
<h3 id="61-c-中的指针">6.1  C++ 中的指针</h3>
<h5 id="611回忆一下指针">6.1.1		回忆一下指针</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Date {
	int year;
	int month;
	int day;
};

int main() {
	Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };
	//p指针指向d结构体
	Date* p = &amp;d;
	//指向结构体的指针，访问结构体的成员使用 -&gt;  (语法糖)
	p-&gt;day = 99;
  //*p 就是结构体即为d 等价于 d.month =12;
	(*p).month = 12;
	//结构体本身，访问结构体的成员使用 .  (语法糖)
	cout &lt;&lt; d.day &lt;&lt; endl;
}
</code></pre>
<h3 id="62-const是什么">6.2 const是什么？</h3>
<p><font color="red">const是常量的意思，被其修饰的变量不可修改</font></p>
<p><font color="red">如果修饰的是类、结构体（的指针），其成员不可以更改</font></p>
<h5 id="611没有被-const-修饰-的结构体">6.1.1		没有被 const  修饰 的结构体</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Date {
	int year;
	int month;
	int day;
};

int main() {
	Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };
	d = d2;
	d.year = 2022;

}
</code></pre>
<h5 id="612被-const-修饰-的结构体">6.1.2		被 const 修饰 的结构体</h5>
<p>结构体不能改</p>
<p>结构体成员也不能改</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Date {
	int year;
	int month;
	int day;
};

int main() {
	const Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };
	d = d2; 			// 报错	结构体不能改-&gt;不能将d指向d2
	d.year = 2022;// 报错	结构体成员也不能改-&gt;不能操作d的成员
}

</code></pre>
<h5 id="613用const-修饰的-指针变量">6.1.3		用const 修饰的 指针变量</h5>
<h5 id="const-date-p-d-后同样等价于结构体指针变量">const Date* p = &amp;d 后同样等价于结构体指针变量</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	Date d = { 2011,2,1 };
	Date d2 = { 2013,9,2 };

	//p指针指向d结构体
	const Date* p = &amp;d;
	p-&gt;day = 99;			// 报错
	(*p).month = 12;	// 报错
	*p = d2;					// 报错
	cout &lt;&lt; d.day &lt;&lt; endl;
}
</code></pre>
<h3 id="63-const-修饰指针p-与-指针指向的存储空间p-的应用区别">6.3  const 修饰指针（p) 与 指针指向的存储空间（*p) 的应用（区别）</h3>
<h5 id="631以下5个指针分别是什么含义">6.3.1		以下5个指针分别是什么含义？</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int age = 10;
	int height = 20;

	const int *p1 = &amp;age;
	int const* p2 = &amp;age;
	int* const p3 = &amp;age;
	const int* const p4 = &amp;age;
	int const* const p5 = &amp;age;

}
</code></pre>
<p><font color="red">结论：const修饰的是其右边的内容</font></p>
<h5 id="632首先看一下">6.3.2		首先看一下</h5>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int age = 10;
	int height = 30;

	int* const p3 = &amp;age;
  // p3所指向的存储空间的值改为20（当前p3指向 age的地址）
	*p3 = 20;	// age = 20;
  // 代码含义： 将height的地址 通过 &amp;height赋值给 p3,此时p3指向height的地址
	p3 = &amp;height; //==================此行代码报错，原因 p3是常量
	// p3所指向的存储空间的值改为40（当前p3指向 height的地址）
  *p3 = 40;	// height = 40;
}
</code></pre>
<h5 id="633五种const-修饰的归类">6.3.3		五种const 修饰的归类 	☆☆☆☆☆</h5>
<h6 id="1const-修饰指针指向的存储空间">1）const 修饰指针指向的存储空间</h6>
<h6 id="2const-修饰指针">2）const 修饰指针</h6>
<h6 id="3const-修饰指针-指针指向的存储空间">3）const 修饰指针 + 指针指向的存储空间</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int age = 10;
	int height = 20;
	// p1（指针）不是常量，*p1（指向的存储空间）是常量
  // p2（指针）不是常量，*p2（指向的存储空间）是常量
	const int *p1 = &amp;age;
	int const* p2 = &amp;age;
  // p3（指针）是常量，*p3（指向的存储空间）不是常量
	int* const p3 = &amp;age;
  // p4（指针）是常量，*p4（指向的存储空间）也是常量
  // p5（指针）是常量，*p5（指向的存储空间）也是常量
	const int* const p4 = &amp;age;
	int const* const p5 = &amp;age;
}
</code></pre>
<h5 id="634-再次理解-const修饰-指针-和-指针指向的存储空间">6.3.4 	再次理解 const修饰 指针 和 指针指向的存储空间</h5>
<p>const 修饰的是	*pstu1（指针指向的存储空间），禁止pstu1指针去修改它所指向的存储空间</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student { int age; };

int main() {
	Student stu1 = { 10 };
	Student stu2 = { 20 };
	//const 修饰的是* pstu1，禁止pstu1指针去修改它所指向的存储空间
	const Student* pstu1 = &amp;stu1;
	*pstu1 = stu2;			// 报错
	(*pstu1).age = 20;	// 报错
	pstu1-&gt;age = 30;		// 报错
	pstu1 = &amp;stu2; //正确
}
</code></pre>
<p>const 修饰的是	pstu2（指针），禁止pstu2指针去重新指向新的地址</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student { int age; };

int main() {
	Student stu1 = { 10 };
	Student stu2 = { 20 };
	//const 修饰的是* pstu1，禁止pstu1指针去修改它所指向的存储空间
	Student* const pstu2 = &amp;stu2;
	*pstu2 = stu2;		// 正确
	(*pstu2).age = 20;	// 正确
	pstu2-&gt;age = 30;	// 正确
	pstu2 = &amp;stu2; //报错
}
</code></pre>
<h1 id="7引用-reference">7.引用 -  Reference</h1>
<h3 id="71-引用reference-的本质是什么">7.1  引用Reference 的本质是什么？</h3>
<p>引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是<font color=red>弱化了的指针</font></p>
<p>在C语言中，使用指针（Pointer）可以间接获取、修改某个变量的值 （在C++可用）</p>
<p>在C++语言中，使用引用（Reference）可以起到跟指针类似的功能</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int v1,int v2) {
	int tmp = v1;
	v1 = v2;
	v2 = tmp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; &quot;a=&quot;&lt;&lt;a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}

//输出：a=10,b=20
</code></pre>
<p>使用 指针（Pointer） 定义变量v1和v2</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int * v1,int *v2) {
	int tmp = *v1;
	*v1 = *v2;
	*v2 = tmp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(&amp;a, &amp;b);
	cout &lt;&lt; &quot;a=&quot;&lt;&lt;a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
//输出：a=20,b=10
</code></pre>
<p>使用 引用（Reference） 定义变量v1和v2</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int&amp; v1, int&amp; v2) {
	int tmp = v1;
	v1 = v2;
	v2 = tmp;
}

int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	getchar();
	return 0;
}
//输出：a=20,b=10
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int&amp; v1, int&amp; v2) {
	int tmp = v1;
	v1 = v2;
	v2 = tmp;
}

int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;
	int c = 30;
	int d = 40;
	swap(c, d);
	cout &lt;&lt; &quot;c=&quot; &lt;&lt; c &lt;&lt; &quot;,d=&quot; &lt;&lt;d &lt;&lt; endl;
	getchar();
	return 0;
}
//输出：	a=20,b=10
				c=40,d=30
</code></pre>
<p>在定义“引用变量”时就赋值-即指向谁（否则 vs 中报错）</p>
<pre><code class="language-cpp">int age =10;
int &amp;refAge = age; // 定义时 赋值
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
	int a = 10;
	int b = 20;
	int&amp; refA = a;
	cout &lt;&lt; &quot;当前 refA=&quot; &lt;&lt; refA &lt;&lt; endl;
	refA = b; // 实际上是将 b的值20 赋值给引用变量 refA
	cout &lt;&lt; &quot;当前 refA=&quot; &lt;&lt; refA &lt;&lt; endl;
	getchar();
	return 0;
}
</code></pre>
<p>一个引用占用一个指针的大小</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://holyson.github.io/ctra.github.io//post/hello-gridea">
                  <h3 class="post-title">
                    Hello 越野跑者
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'c8095f1dffb004fc399d',
        clientSecret: '47a97b6ab252e98d6f37aabdf74dd73c39722e6d',
        repo: 'blog-comment',
        owner: 'Holyson',
        admin: ['Holyson'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
